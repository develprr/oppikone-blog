<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="On Strengths And Weaknesses Of ReactJS">
    <meta name="author" content="Oppikone">

    <title>A Brief Introduction To ReactJS</title>

    <!-- Bootstrap Core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Theme CSS -->
    <link href="css/clean-blog.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div style="display:none" class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>
                <a class="navbar-brand" href="http://www.oppikone.fi">Oppikone</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div  class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul style display="none" class="nav navbar-nav navbar-right">
                    <li>
                        <a href="http://www.oppikone.fi">Oppikone</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="intro-header" style="background-image: url('http://www.oppikone.fi/templates/oppikone/files/nature/world-footer.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>A Brief Introduction To ReactJS</h1>
                        <h2 class="subheading">On Strengths And Weaknesses Of ReactJS</h2>
                        <span class="meta">Posted by <a href="#">Heikki Kupiainen/Oppikone</a> on 2016-11-21</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Post Content -->
    <article>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          		<h3>Why ReactJS?</h3><p/>

If you think you are good at JavaScript programming chances are that you still won't get a project unless you are familiar with ReactJS.
That is because ReactJS is momentarily in the center of a hype-storm and will remain there until the next 
framework pops up that will get the hyper crown. Remember, the previous hyper king was AngularJS
and before that there were many others like Backbone, JavaScriptMVC, EmberJS etc. It is typical for
inexperienced programmers to emphasize importance of frameworks over design patterns. One good example of this kind of framework over-glorification is the much-hyped "dependency injection support" in AngularJS that I even wrote
<a href="http://www.oppikone.fi/blog/dependency-injection-in-javascript.html">another blog post</a> about - but that's another story.<p/>

<h3>How About Networking?</h3><p/>

Interestingly, there is a common misconception that ReactJS kind of "solves" the UI. But a serious browser based single page app (SPA), for instance, inevitably
needs networking functionality (AJAX). Yet ReactJS' "networking" functionality is a very primitive fetch wrapper function.
That does not compare well with JQuery's advanced AJAX options. It is okay to use ReactJS for rendering views but really,
you'll be better off using JQuery for networking. And once you include JQuery into your project, why not to use also JQuery's 
superior DOM manipulation methods? But of course, that would be in conflict with ReactJS's sweet "virtual DOM" idea, right?<p/>
When you are looking for someone to create a web app, requiring ReactJS skills without even mentioning JQuery is a bit like ordering a car without an engine. But of course,
things don't need to be that black and white. There is nothing that can prevent you from loading the data with JQuery and then initializing ReactJS elements with that data.
I'll show later how!
<p>
If what you actually want to do is rendering views on server side using ReactJS then you are just reinventing the wheel
and doing exactly the same thing what they always did with PHP, JSP, ASP, RoR, Django etc. Then you are just using ReactJS as a yet another server side
templating engine - even if this time JavaScript based and decorated with new buzzwords - but conceptually really just continuing a tradition from the last millenium. It is okay to do so and 
it's great for creating static content but then just don't call it SPA because the point of an SPA is that the browser client renders the views and not the server. And that
requires networking with AJAX because the client needs to load templates and data dynamically from the server.
Ideally a true SPA only loads data and templates - not readily rendered views.<p/>

<h3>Installation</h3><p/>

It's always useful to get started with new frameworks by checking out some complete examples that already have
a readily made project structure. For ReactJS, there are many tutorial repos available for instance 
<a href="https://github.com/arkency/reactjs_koans">Koans ReactJS github repo</a>. 
But of course, you can also install a very basic example project directly from <a href="https://facebook.github.io/react/docs/installation.html">Facebook's repository</a>.
<p/>
In my last <a href="http://www.oppikone.fi/blog/javascript-oop.html">blog post</a> I introduced some (who knows?) controversial 
OOP hacks using car-related examples to demonstrate inheritance. Therefore, we'll remain in the car manufacturing business in this
blog post as well, creating a web frontend for our car models.<p/>

It's time to put some Car concepts into production and create a Car App with ReactJS! For this reason, the 
sample project will have name <b>my-car-app</b>. As a prequisite, first install ReactJS toolkit: <p/>

<b>npm install -g create-react-app</b><p/>

But please note that if you use Ubuntu Linux and want to install NodeJS via apt-get you will encounter a problem when trying to use
ReactJS-related npm tools that depend on NodeJS. When you execute:<p/>

<b>create-react-app my-car-app</b>
<p/>
There are changes that you'll get an error:<p/>
	
<b>/usr/bin/env: node: No such file or directory</b><p/>

No need to panic! The problem occurs only because in Ubuntu, NodeJS is named as "nodejs" while
npm expects "node". You just need to create a symbolic link
that fixes the problem: <p/>

<b>sudo ln -s /usr/bin/nodejs /usr/bin/node</b><p/>

<p>Beware that your default NodeJS version might be deprecated. If that is the case you'll get a warning when using npm
to install ReactJS related tools - and even worse: they won't work!</p> Just download the newest NodeJS version from <a href="https://nodejs.org">NodeJS web site</a>
and extract it to wherever you like. Remember to update the symlink accordingly. I have: <p/>

<b>sudo ln -s /home/heikki/tools/node-v6.9.1-linux-x64/bin/node /usr/bin/node</b><p/>

If this doesn't fix it it's probably because you are using operating system's default npm installation which might
be deprecated. Uninstall npm and create a symlink to npm installation as well:<p/>

<b>sudo ln -s /home/heikki/tools/node-v6.9.1-linux-x64/bin/npm /usr/bin/npm</b><p/>

Then create the project directory (if you didn't do so yet) and start the development server:<p/>
<b>create-react-app my-car-app</b><br/>
<b>cd my-car-app<br/>
npm start</b><p/>

<h3>Creating First App With ReactJS</h3><p/>

If everything went right you should have a skeleton for your first ReactJS app by now. The main application file has
been generated as ./src/App.js. You can just start tweaking it to create an app you always wanted to have.<p/>

When you want to publish the production version of your App make sure that you have a pushstate server installed:<p/>

<b>npm install -g pushstate-server</b><p/>

Note that you might run into problems if you are running Debian "Wheezy". If your command line does not find pushstate-server then
make sure you have included it into your path. On Debian and Ubuntu you can edit .bashrc file. I added a line as follows: <p/>

<b>export PATH="$PATH:$HOME/tools/node-v6.9.1-linux-x64/bin"</b><p/>

It's particularly nice to have pushstate-server working because it helps you try out your build before publishing it.
So, finally build your app:<p/>

<b>npm run build</b><p/>

<iframe style="border-radius:10x;max-width:300px;width:100%;height:300px" src="http://www.oppikone.fi/reactjs-demo/my-car-app-0"></iframe><p/>

That's how it works. The result is also available <a href="http://www.oppikone.fi/reactjs-demo/my-car-app-0">here.</a> 

I also created <a href="https://github.com/develprr/reactjs-tutorial">a GitHub repository</a> for the code samples I wrote for this demo. Feel free
to check it out.

<p>Now, let's take a look at ReactJS's ideology. ReactJS is a framework really focused in manipulating DOM, introducing
a concept of "Virtual DOM". You can declare your own elements and use them just as if they were any normal DOM elements.<p/>

<textarea style="width:100%;height:300px;" >
class AppTitle extends React.Component {
    render(){
        return (
            <h1>This is a react Demo App for {this.props.name}</h1>
        );
    }
}
</textarea>


And syntax for using CustomAppHeader would look like this:<p/>
<textarea style="width:100%;" >
<AppTitle name="Cars"/>
</textarea><p/>

<h3>Creating Complex Components</h3>

Next, I'll show how to create more complex components. When you render any virtual DOM component you can embed your custom
components into the output html of each component. That will, by definition, lead to more complex composite components. But before that,
let's create a hard-coded dummy component to render a html list element containing some cars:<p/>

<textarea style="width:100%;height:400px;" >
class CarList extends React.Component {
  render() {
    return (
      <div className="car-list">
        <h3>Car List for {this.props.name}</h3>
        <ul>
          <li>Audi</li>
          <li>Porsche</li>
          <li>Tesla</li>
        </ul>
      </div>
    );
  }
}
</textarea><p/>

Now, we are ready to add the CarList component to the main view and have our cars listed on the web page:<p/>

<textarea style="width:100%;height:600px;" >
class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>A ReactJS Demo by Heikki / Oppikone </h2>
        </div>
        <p className="App-intro">
		<AppTitle name="Cars" />
        </p>
	<p className="App-carlist">
		<CarList/>
	</p>
      </div>
    );
  }
}
</textarea>

<p>Looks nice? Hold on! The truth is that we created some code that is not browser-supported JavaScript. ReactJS compiles this code into a
machine-generated "bundle.js" file that isn't a particularly encouraging target for debugging. You don't need all this to write object oriented JavaScript code.
Have a look at my article on <a href="http://www.oppikone.fi/blog/javascript-oop.html">OOP in JavaScript</a> for retrospection.
But don't let me discourage you! Let's proceed and create a more advanced car list component that takes an array of car models as input parameter
and renders it as an html list:<p/>

<textarea style="width:100%;height:400px;" >
class ParameterCarList extends React.Component {
	render() {
		var carMap = this.props.cars.map((car) =>
			<li key={car.toString()}>
			      {car}
			</li>
  		);
		return(
			<ul>{carMap}</ul>
		)
	}
}
</textarea><p/>

If you think that the code above turns a categorically drop-dead simple concept such as rendering a list in a template into
an overly complicated and counter-intuitive hogwash, then take a look at some conventional template engine such as MustacheJS or EJS. Now, let's embed <b>ParameterCarList</b> into the main app:<p/>

<textarea style="width:100%;height:150px;"> 
<ParameterCarList cars={this.getCarList()} />
</textarea><p/>

Note that the ParameterCarList component here takes the value for cars parameter from getCarList function. We'll implement that
function in our main <b>App</b> class:

<textarea style="width:100%;height:200px;" >
getCarList() {
	return [
		"Audi",
		"Porsche",
		"Tesla"
	];
}
</textarea><p/>

<p>Needless to say, a ul/li list in html without any formatting will look so ugly that I don't even dare to add a link to the outcome
of the code I described above before I add some responsive formatting. And what is the best solution to format html? 
<a href="http://www.oppikone.fi/blog/responsive-ui-with-bootstrap-and-reactjs.html">Bootstrap of course!</a> 
With Bootstrap you can add reasonable and responsive layouts to your App no matter whether you created it with ReactJS or anything else. 

Our car list formatted with Bootstrap will look like this:<p/>

<iframe src="http://www.oppikone.fi/reactjs-demo/my-car-app-1" style="border-radius:10x;width:100%;height:500px"></iframe><p/>

The example is also available <a href="http://www.oppikone.fi/reactjs-demo/my-car-app-1">here.</a><p/>

<h3>Filtering Lists</h3><p/>

We want to stay in car business we must be able to offer many different car models. And when we add more cars to the list 
then users must be abl to filter the list somewhat to find exactly those cars they are looking for. Let's implement a CarFilterList that
includes a search field, list filtering logic and the actual list element, all formatted nicely with Bootstrap:<p/>

<textarea style="width:100%;height:1500px;" >
class CarFilterList extends React.Component {
	
	constructor(props) {
		super(props);
		this.handleChange = this.handleChange.bind(this);
		this.state = {items: this.getAllItems(), initialItems: this.getAllItems()};
	}
	getAllItems() {
		return  [
				"Audi",
				"Porsche",
				"Tesla",
				"Bugatti",
				"Ferrari",
				"Lamborghini"
			];
	}

	handleChange(event) {
		var searchPhrase = event.target.value;
		var items = this.state.initialItems;
		var filteredItems = [];
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			if (item.toLowerCase().indexOf(searchPhrase.toLowerCase()) === -1) {
				continue;
			}
			filteredItems.push(item);
		}
		this.setState({items: filteredItems});
		
	}

	
	render() {
		return (
			<div className="form-group row">
				<p/>
				<div className="col">
					<input className="form-control" type="text" placeholder="Search" onChange={this.handleChange}/>
				</div>
				<p/>
				<BootstrapList items={this.state.items}/>
			</div>
			
		);
 	 }
}
</textarea><p/>

Note that I have embedded a <b>BootstrapList</b> component inside my <b>CarFilterList</b>. That's because I want CarFilterList
to contain the logic for filtering cars and BootstrapList a somewhat more general component that just renders any list
it gets as a parameter:

<textarea style="width:100%;height:500px;" >
class BootstrapList extends React.Component {
	render() {
		var itemMap = this.props.items.map((item) =>
			<li className="list-group-item" key={item.toString()}>
			      {item}
			</li>
  		);
		return(
			<div className="container-fluid">
				<ul className="list-group">{itemMap}</ul>
			</div>
		)
	}
}
</textarea><p/>

The result is going to look like this:<p/>

<iframe src="http://www.oppikone.fi/reactjs-demo/my-car-app-2" style="border-radius:10x;width:100%;height:600px"></iframe><p/>

The example is also available <a href="http://www.oppikone.fi/reactjs-demo/my-car-app-2">here.</a><p/>

<h3>Some Remarks</h3><p/>
 
Aside from all hype, what we have here is really yet another templating engine. "Components" are really partial views that
render other partial views. However, unlike many template engines, ReactJS virtual DOM mixes templates into program code whereas 
traditional templating engines mix code into templates. However, If you like to harness the power of JQuery and separate templates
from the controller layer, take a look at template engines like <a href="http://www.embeddedjs.com/">EmbeddedJS</a> 
or <a href="http://mustache.github.io/">MustacheJS</a>. There are also many others. It doesn't matter so much which 
template engine you choose. The difference is usually mostly only syntactical since rendering templates is a rather universal
principle.<p/>

<h3>Model Bindings</h3><p/>

ReactJS model binding provides a certain advantage in updating the model layer from user inputs. It is a nice
practical shortcut that you can add a model binding to a UI element that will automatically update
the model when user edits a text area, text input field or selects a checkbox. This works OK for very simple
core components. Yet it is not that much more difficult to just add a classic event listener "onchange" 
and write an updater method. Basic model binding will fall short when 
you try to add a just little bit more advanced UI widget. And it will fall short when you want to add some custom validation.
And you <i>will be</i> needing custom validations. At the end of the day, you will be writing custom updater methods anyway.<p/>

<h3>Putting It Into Context</h3><p/>

There are some parties that erratically praise ReactJS as some kind of a silver bullet in
UI development. However, ReactJS covers really only the View aspect of MVC (Model-View-Controller) trinity. 
Any software, whether running in a browser or somewhere else, 
consists of many aspects and rendering views is just a tip of the ice berg.<p/>
To build good software, ReactJS is not all what you need. You can use ReactJS to render views but you don't need ReactJS really
to do it. There are many alternatives for rendering views. Also ReactJS's virtual DOM operations are rather cumbersome compared
with JQuery's power and flexibility. ReactJS tries to solve this issue by using JSX templates. However, JSX has a downside that it
must be embedded in "JavaScript" code (which isn't true JavaScript either) that is then compiled into real JavaScript. If you
really want to separate templates from JavaScript code (which is truly recommendable) you'll be better off when you
use some templating engine such as EmbeddedJS (EJS) or MustacheJS. Those templates can be loaded dynamically from server on demand using Ajax.
When creating a true SPA with serious networking capability, JQuery is what you need for networking. And once you use JQuery,
why not to take advantage of all power it has? And when you render templates, use a solution that doesn't mess controllers with views!<p/>
                </div>
            </div>
        </div>
    </article>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul style="display:none" class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
		    <p class="copyright text-muted">View this article on <a href="https://github.com/develprr/oppikone-blog/commits/master/brief-introduction-to-reactjs.html">GitHub!</a></p>
                    <p class="copyright text-muted">Copyright &copy; Oppikone 2017</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>

</body>

</html>