<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="On Strengths And Weaknesses Of ReactJS">
    <meta name="author" content="Oppikone">

    <title>A Brief Introduction To ReactJS</title>

    <!-- Bootstrap Core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Theme CSS -->
    <link href="css/clean-blog.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div style="display:none" class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>
                <a class="navbar-brand" href="http://www.oppikone.fi">Oppikone</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div  class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul style display="none" class="nav navbar-nav navbar-right">
                    <li>
                        <a href="http://www.oppikone.fi">Oppikone</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="intro-header" style="background-image: url('http://www.oppikone.fi/templates/oppikone/files/nature/world-footer.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>A Brief Introduction To ReactJS</h1>
                        <h2 class="subheading">On Strengths And Weaknesses Of ReactJS</h2>
                        <span class="meta">Posted by <a href="#">Heikki Kupiainen/Oppikone</a> on 2016-11-21</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Post Content -->
    <article>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          		<h3>Why ReactJS?</h3><p/>

If you think you are good at JavaScript programming chances are that you still won't get a project unless you are familiar with ReactJS.
That is because ReactJS is momentarily in the center of a hype-storm and will remain there until the next 
framework pops up that will get the hyper crown. Remember, the previous hyper king was AngularJS
and before that there were many others like Backbone, JavaScriptMVC, EmberJS etc. It is typical for
inexperienced programmers to emphasize importance of frameworks over design patterns. One good example of this kind of framework over-glorification is the much-hyped "dependency injection support" in AngularJS that I even wrote
<a href="http://www.oppikone.fi/blog/dependency-injection-in-javascript.html">another blog post</a> about - but that's another story.<p/>

<h3>How About Networking?</h3><p/>

Interestingly, there is a common misconception that ReactJS kind of "solves" the UI. But a serious browser based single page app (SPA), for instance, inevitably
needs networking functionality (AJAX). Yet ReactJS' "networking" functionality is a very primitive fetch wrapper function.
That does not compare well with JQuery's advanced AJAX options. It is okay to use ReactJS for rendering views but really,
you'll be better off using JQuery for networking. And once you include JQuery into your project, why not to use also JQuery's 
superior DOM manipulation methods? But of course, that would be in conflict with ReactJS's sweet "virtual DOM" idea, right?<p/>
When you are looking for someone to create a web app, requiring ReactJS skills without even mentioning JQuery is a bit like ordering a car without an engine. But of course,
things don't need to be that black and white. There is nothing that can prevent you from loading the data with JQuery and then initializing ReactJS elements with that data.
I'll show later how!
<p>
If what you actually want to do is rendering views on server side using ReactJS then you are just reinventing the wheel
and doing exactly the same thing what they always did with PHP, JSP, ASP, RoR, Django etc. Then you are just using ReactJS as a yet another server side
templating engine - even if this time JavaScript based and decorated with new buzzwords - but conceptually really just continuing a tradition from the last millenium. It is okay to do so and 
it's great for creating static content but then just don't call it SPA because the point of an SPA is that the browser client renders the views and not the server. And that
requires networking with AJAX because the client needs to load templates and data dynamically from the server.
Ideally a true SPA only loads data and templates - not readily rendered views.<p/>

<h3>Installation</h3><p/>

It's always useful to get started with new frameworks by checking out some complete examples that already have
a readily made project structure. For ReactJS, there are many tutorial repos available for instance 
<a href="https://github.com/arkency/reactjs_koans">Koans ReactJS github repo</a>. 
But of course, you can also install a very basic example project directly from <a href="https://facebook.github.io/react/docs/installation.html">Facebook's repository</a>.
<p/>
In my last <a href="http://www.oppikone.fi/blog/javascript-oop.html">blog post</a> I introduced some (who knows?) controversial 
OOP hacks using car-related examples to demonstrate inheritance. Therefore, we'll remain in the car manufacturing business in this
blog post as well, creating a web frontend for our car models.<p/>

It's time to put some Car concepts into production and create a Car App with ReactJS! For this reason, the 
sample project will have name <b>my-car-app</b>. As a prequisite, first install ReactJS toolkit: <p/>

<b>npm install -g create-react-app</b><p/>

But please note that if you use Ubuntu Linux and want to install NodeJS via apt-get you will encounter a problem when trying to use
ReactJS-related npm tools that depend on NodeJS. When you execute:<p/>

<b>create-react-app my-car-app</b>
<p/>
There are changes that you'll get an error:<p/>
	
<b>/usr/bin/env: node: No such file or directory</b><p/>

No need to panic! The problem occurs only because in Ubuntu, NodeJS is named as "nodejs" while
npm expects "node". You just need to create a symbolic link
that fixes the problem: <p/>

<b>sudo ln -s /usr/bin/nodejs /usr/bin/node</b><p/>

<p>Beware that your default NodeJS version might be deprecated. If that is the case you'll get a warning when using npm
to install ReactJS related tools - and even worse: they won't work!</p> Just download the newest NodeJS version from <a href="https://nodejs.org">NodeJS web site</a>
and extract it to wherever you like. Remember to update the symlink accordingly. I have: <p/>

<b>sudo ln -s /home/heikki/tools/node-v6.9.1-linux-x64/bin/node /usr/bin/node</b><p/>

If this doesn't fix it it's probably because you are using operating system's default npm installation which might
be deprecated. Uninstall npm and create a symlink to npm installation as well:<p/>

<b>sudo ln -s /home/heikki/tools/node-v6.9.1-linux-x64/bin/npm /usr/bin/npm</b><p/>

Then create the project directory (if you didn't do so yet) and start the development server:<p/>
<b>create-react-app my-car-app</b><br/>
<b>cd my-car-app<br/>
npm start</b><p/>

<h3>Creating First App With ReactJS</h3><p/>

If everything went right you should have a skeleton for your first ReactJS app by now. The main application file has
been generated as ./src/App.js. You can just start tweaking it to create an app you always wanted to have.<p/>

When you want to publish the production version of your App make sure that you have a pushstate server installed:<p/>

<b>npm install -g pushstate-server</b><p/>

Note that you might run into problems if you are running Debian "Wheezy". If that's the case upgrade your Debian to "Jessie" or just use Ubuntu.<p/>

And finally build your app:<p/>

<b>npm run build</b><p/>

<iframe style="border-radius:10x;max-width:300px;width:100%;height:300px" src="http://www.oppikone.fi/reactjs-demo/my-car-app-0"></iframe><p/>

That's how it works. The result is also available <a href="http://www.oppikone.fi/reactjs-demo/my-car-app-0">here.</a> 

I also created <a href="https://github.com/develprr/reactjs-tutorial">a GitHub repository</a> for the code samples I wrote for this demo. Feel free
to check it out.

<p>Now, let's take a look at ReactJS's ideology. ReactJS is a framework really focused in manipulating DOM, introducing
a concept of "Virtual DOM". You can declare your own elements and use them just as if they were any normal DOM elements.<p/>

<textarea style="width:100%;height:300px;" >
var CustomAppHeader = React.createClass( {
	render: function() {
		return (
			<h1>This is a Demo App for {this.props.name}</h1>
		);
	}
});
</textarea>


And syntax for using CustomAppHeader would look like this:<p/>
<textarea style="width:100%;" >
<CustomAppHeader name="Cars"/>
</textarea><p/>

<h3>Creating Complex Components</h3>

Next, I'll show how to create more complex components. When you render any virtual DOM component you can embed your custom
components into the output html of each component. That will, by definition, lead to more complex composite components. Given that
we want to list car branches on our website, we'll need, first of all, introduce a list component. A list component
takes as input an array of strings and renders them in a list element:<p/>

<textarea style="width:100%;height:300px;" >

var List = React.createClass({
  render: function(){
    return (
      <ul>
      {
        this.props.items.map(function(item) {
          return <li key={item}>{item}</li>
        })
       }
      </ul>
    )  
  }
</textarea><p/>

The next step is to populate the list with car models. In a production app I would load the list with AJAX, preferrably with JQuery,
from a microservice, but at this point we'll just have a hard coded car list. Therefore I'll implement a CarList element that
contains the car data and then renders those cars using the readily made List component:<p/>

<textarea style="width:100%;height:600px;" >

var CarList = React.createClass({
  
  getInitialState: function(){
     return {
       initialItems: [
         "Audi",
         "Ferrari",
         "Porche",
         "Tesla"
       ],
       items: []
     }
  },
  componentWillMount: function(){
    this.setState({items: this.state.initialItems})
  },
  render: function(){
    return (
      <div className="car-list">
      	<List items={this.state.items}/>
      </div>
    );
  }
});

</textarea><p/>

CarList component has basicly an "items" property which will contain the car list. When the component mounts, the items property
will be populated with component's initial items, which is hard coded string array. Note that the inital state is the point to where
we'll intervene when we want to get serious and load the data from a microservice instead. Now, we are ready to add
the CarList component to the main view and have our cars listed on the web page:<p/>

<textarea style="width:100%;height:500px;" >

class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>A ReactJS Demo by Heikki / Oppikone </h2>
        </div>
        <p className="App-intro">
		<AppTitle name="Cars" />
        </p>
	<p className="App-carlist">
		<CarList/>
	</p>
      </div>
    );
  }
}


</textarea>

<p>Looks nice? But aside from all hype, what we have here is really yet another templating engine. "Elements" are really partial views that
render other partial views. However, unlike many template engines, ReactJS virtual DOM mixes templates into program code whereas 
traditional templating engines mix code into templates. However, If you like to harness the power of JQuery and separate templates
from the controller layer, take a look at template engines like <a href="http://www.embeddedjs.com/">EmbeddedJS</a> 
or <a href="http://mustache.github.io/">MustacheJS</a>.<p/>

<h3>Model Bindings</h3><p/>

ReactJS model binding provides a certain advantage in updating the model layer from user inputs. It is a nice
practical shortcut that you can add a model binding to a UI element that will automatically update
the model when user edits a text area, text input field or selects a checkbox. This works OK for very simple
core components. Yet it is not that much more difficult to just add a classic event listener "onchange" 
and write an updater method. Basic model binding will fall short when 
you try to add a just little bit more advanced UI widget. And it will fall short when you want to add some custom validation.
And you <i>will be</i> needing custom validations. At the end of the day, you will be writing custom updater methods anyway.<p/>

<h3>Putting It Into Context</h3><p/>

There are some parties that erratically praise ReactJS as some kind of a silver bullet in
UI development. However, ReactJS covers really only the View aspect of MVC (Model-View-Controller) trinity. 
Any software, whether running in a browser or somewhere else, 
consists of many aspects and rendering views is just a tip of the ice berg.<p/>
To build good software, ReactJS is not all what you need. You can use ReactJS to render views but you don't need ReactJS really
to do it. There are many alternatives for rendering views. Also ReactJS's virtual DOM operations are rather cumbersome compared
with JQuery's power and flexibility. ReactJS tries to solve this issue by using JSX templates. However, JSX has a downside that it
must be embedded in "JavaScript" code (which isn't true JavaScript either) that is then compiled into real JavaScript. If you
really want to separate templates from JavaScript code (which is truly recommendable) you'll be better off when you
use some templating engine such as EmbeddedJS (EJS) or MustacheJS. Those templates can be loaded dynamically from server on demand using Ajax.
When creating a true SPA with serious networking capability, JQuery is what you need for networking. And once you use JQuery,
why not to take advantage of all power it has? And when you render templates, use a solution that doesn't mess controllers with views!<p/>
                </div>
            </div>
        </div>
    </article>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul style="display:none" class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
		    <p class="copyright text-muted">View this article on <a href="https://github.com/develprr/oppikone-blog/commits/master/brief-introduction-to-reactjs.html">GitHub!</a></p>
                    <p class="copyright text-muted">Copyright &copy; Oppikone 2017</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>

</body>

</html>