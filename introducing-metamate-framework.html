<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A Simple Alternative to Redux for App Data Management">
    <meta name="author" content="Oppikone">

    <title>The Metamatic Framework</title>

    <!-- Bootstrap Core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Theme CSS -->
    <link href="css/clean-blog.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div style="display:none" class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>
                <a class="navbar-brand" href="http://www.oppikone.fi">Oppikone</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div  class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul style display="none" class="nav navbar-nav navbar-right">
                    <li>
                        <a href="http://www.oppikone.fi">Oppikone</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="intro-header" style="background-image: url('/images/full/introducing-metamate-framework.png')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading" style="background-color:rgba(50,50,50,0.3)">
                        <h1 style="color:white">The Metamatic Framework</h1>
                        <h2 style="color:yellow" class="subheading">A Simple Alternative to Redux for App Data Management</h2>
                        <span class="meta">Posted by <a href="#">Heikki Kupiainen/Oppikone</a> on 06.07.2018 11:45:15</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Post Content -->
    <article>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          		<h1 id="the-easier-way-to-handle-data-in-your-app">The Easier Way to Handle Data in Your App</h1>
<p>This article is for you if you are familiar with ReactJS framework for frontend development and maybe even have already wondered how you should handle data in your browser-based piece of software. This article is also for you if you know what is Redux and ever wondered if there is a more straightforward way to achieve central data management in a web app.</p>
<p>In my <a href="http://www.oppikone.fi/blog/introducing-synchronous-dispatcher.html" title="Introducing Synchronous Dispatcher">previous article</a> I wrote about the minuscule event-dispatching framework with a promise to greatly simplify frontend application development. In this article I will introduce the missing piece of the puzzle and show how to use Synchronous Dispatcher to create fantastic software.</p>
<p><strong>The Metamatic Framework</strong>, that I have designed for you, Dear Coder, to make your life easier, is a Redux-alternative for centrally managing data in your frontend app.</p>
<p>In these examples I'll use ES6 syntax but there should be absolutely no problem to use TypeScript or JavaScript either for Metamatic coding!</p>
<h2 id="so-what-is-the-metamatic-framework">So What Is the Metamatic Framework?</h2>
<p>The Metamatic framework is a little bit of software code - in deed, a very very very tiny bit of software code. Actually it's not at all so much about code, it's rather a new way or concept of managing the data in your app. It is meant to be used together with JavaScript, TypeScript, EcmaScript variants. You can integrate it into your React app or embed it in Angular framework or anything that speaks JavaScript.</p>
<p>People use typically data handling frameworks such as Redux for coding with these languages. I have used Redux in quite some projects. Redux is a great solution to simplify application data management. But it also can be at times frustrating when you must write too much code to get some very simple things done. I want to offer here a more simplistic solution that essentially offers the same core benefits as Redux but needs far less coding from you to get things done.</p>
<h2 id="why-use-metamatic">Why Use Metamatic?</h2>
<p>When you code frontend software that run inside browser (or phone or wherever) and once you advance further than creating some &quot;Hello World&quot; apps, you will notice that the issue with data integrity grows in size. You will have many tabs and sections in your app. You implement data retrieval functions that get snippets of data from the server.</p>
<p>It will all go well until you start facing data integrity issues. The user updated some data (their phone number, whatever) on one form but when they enter another tab or section they will see to their dismay that the data they just updated was not changed accordingly on the other tab.</p>
<p>The reason to these kinds of problems is that there are several copies of the same data in different parts of the application. The obvious solution to this is to place all data into one central part of the application. When the user changes the data in some part of the app, then the corresponding data entry is updated in the central data location - from there the change then automatically radiates to all parts of the app where it is being displayed. There are several ways to implement this kind of central data handling.</p>
<h2 id="getting-started-with-metamatic">Getting Started With Metamatic</h2>
<p>When you have created your first React app and you have some kind of form for data manipulation, then it's time to connect that form to the central Metamatic data storage. Let's say that we have created a car app web store and we have created a component for showing car details. In <strong><a href="https://github.com/develprr/metamatic-car-app/blob/master/src/component/CarDetails.js" title="CarDetails">CarDetails</a></strong> component, we want to show details of some available car model. Now, we need that CarDetails component to retrieve the car data.</p>
<p>Okay, now that we have <strong>CarDetails</strong> component, let's import first the essential functions from <strong><a href="https://www.npmjs.com/package/synchronous-dispatcher" title="Synchronous Dispatcher">synchronous-dispatcher</a></strong>. Add the import statement to the beginning of your class:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> handle<span class="op">,</span> handleAll<span class="op">,</span> dispatch<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;synchronous-dispatcher&#39;</span></code></pre></div>
<p>And don't forget to install <strong>synchronous-dispatcher</strong> before using it, of course! With Yarn or Npm:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">npm install synchronous<span class="op">-</span>dispatcher</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">yarn install synchronous<span class="op">-</span>dispatcher</code></pre></div>
<p>That's it!</p>
<h2 id="connect-your-component-to-the-metamatic-data-store">Connect Your Component to the Metamatic Data Store</h2>
<p>Now we have all essential data event methods in our use! The next thing we need is to connect our <strong><a href="https://github.com/develprr/metamatic-car-app/blob/master/src/component/CarDetails.js" title="CarDetails">CarDetails</a></strong> class to the Metamatic global data state, which I call <strong>MetaStore</strong>. MetaStore is the central data store that is responsible for radiating the data to all parts of the app that are listening, when the data changes. When we want to connect a React component to MetaStore, we must define which events we want our React component to listen to. Let's decide that when the car data is loaded from the server by MetaStore, <strong><a href="https://github.com/develprr/metamatic-car-app/blob/master/src/component/CarDetails.js" title="CarDetails">CarDetails</a></strong> component must be updated. The idea is that the local state of the UI component is synchronized with the central metaStore. I'll show here how to do it. First of all, we must make sure that the car data is available for <strong><a href="https://github.com/develprr/metamatic-car-app/blob/master/src/component/CarDetails.js" title="CarDetails">CarDetails</a></strong> component. Therefore we enable <strong><a href="https://github.com/develprr/metamatic-car-app/blob/master/src/component/CarDetails.js" title="CarDetails">CarDetails</a></strong> component's constructor to shout into the bit space that we need car data:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">constructor</span>(props) <span class="op">{</span>
    <span class="kw">super</span>(props)<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">state</span> <span class="op">=</span> <span class="op">{};</span>
    <span class="at">dispatch</span>(<span class="st">&#39;REQUEST-CAR-DATA&#39;</span>)<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Quite straightforward, isn't it? We have connected <strong><a href="https://github.com/develprr/metamatic-car-app/blob/master/src/component/CarDetails.js" title="CarDetails">CarDetails</a></strong> component to the central data storage with practically one single line of code! Now let's make sure that also the component's local state is synchronized with MetaStore. We must add a handle function that will update the component's state accordingly when CAR-DATA-CHANGE event is received:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">componentDidMount</span>() <span class="op">{</span>
    <span class="at">handle</span>(<span class="st">&#39;CAR-DATA-CHANGE&#39;</span><span class="op">,</span> (carDetails) <span class="op">=&gt;</span> <span class="kw">this</span>.<span class="at">setState</span>(<span class="op">{</span>carDetails<span class="op">}</span>))<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>Quite painless, isn't it? And CarDetails' render method will then function quite normally, interacting with the component's state:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">render</span>() <span class="op">{</span>
    <span class="kw">let</span> carDetails <span class="op">=</span> <span class="kw">this</span>.<span class="va">state</span>.<span class="at">carDetails</span><span class="op">;</span>
    <span class="cf">return</span> carDetails <span class="op">?</span> (
        <span class="op">&lt;</span>ul className<span class="op">=</span><span class="st">&quot;list-group&quot;</span><span class="op">&gt;</span>
          <span class="op">&lt;</span>li className<span class="op">=</span><span class="st">&quot;list-group-item&quot;</span><span class="op">&gt;&lt;</span>h3<span class="op">&gt;{</span><span class="va">carDetails</span>.<span class="at">model</span><span class="op">}&lt;</span><span class="ss">/h3&gt;&lt;/li</span><span class="op">&gt;</span>
          <span class="op">&lt;</span>li className<span class="op">=</span><span class="st">&quot;list-group-item&quot;</span><span class="op">&gt;</span>Top Speed: <span class="op">{</span><span class="va">carDetails</span>.<span class="at">speed</span><span class="op">}&lt;</span><span class="ss">/li&gt;</span>
<span class="ss">          &lt;li className=&quot;list-group-item&quot;&gt;Color: {carDetails.color}&lt;/li</span><span class="op">&gt;</span>
          <span class="op">&lt;</span>li className<span class="op">=</span><span class="st">&quot;list-group-item&quot;</span><span class="op">&gt;</span><span class="dt">Price</span><span class="op">:</span> <span class="op">{</span><span class="va">carDetails</span>.<span class="at">price</span><span class="op">}&lt;</span><span class="ss">/li&gt;</span>
<span class="ss">        &lt;/ul</span><span class="op">&gt;</span>
    ) <span class="op">:</span> <span class="kw">null</span><span class="op">;</span>
<span class="op">}</span></code></pre></div>
<h2 id="implementing-a-metamatic-data-storage-metastore">Implementing a Metamatic Data Storage, MetaStore</h2>
<p>Let's implement the actual metamatic data storage, MetaStore. Essentially, MetaStore just needs the exactly same super simple utility functions from synchronous-dispatcher as do all other parts of the app as well. But now that we want our MetaStore to actually load the datarom server, let's add an AJAX library to MetaStore. I'll use <strong>axios</strong> but be free to use any other library as you wish. Let's add the essential imports to the beginning of MetaStore.js file:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> handle<span class="op">,</span> dispatch <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;synchronous-dispatcher&#39;</span>
<span class="im">import</span> axios <span class="im">from</span> <span class="st">&#39;axios&#39;</span><span class="op">;</span></code></pre></div>
<p>Then, let's define the actual MetaStore object:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">const</span> metaStore <span class="op">=</span> <span class="op">{</span>
  <span class="dt">carData</span><span class="op">:</span> <span class="kw">null</span>
<span class="op">}</span></code></pre></div>
<p>Let's also create the initialization function for MetaStore:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">export</span> <span class="kw">const</span> initMetaStore <span class="op">=</span> () <span class="op">=&gt;</span> <span class="op">{};</span></code></pre></div>
<p>Now, it's time to get serious. We want to make sure that MetaStore will load car data when it receives request for car data! We expand initMetaStore function to respond to car data request and do something when any component in the application dispatches a request for car data. Let's make metaStore to listen for REQUEST-CAR-DATA event and dispatch a car CAR-DATA-CHANGE event if the car data is available. If not, MetaStore shall delegate the problem and dispatch 'LOAD-CAR-DATA' event. Then some other part in the app can listen to that event and react in an appropriate way:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">export</span> <span class="kw">const</span> initMetaStore <span class="op">=</span> () <span class="op">=&gt;</span> <span class="op">{</span>
   <span class="at">handle</span>(<span class="st">&#39;REQUEST-CAR-DATA&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="cf">if</span> (<span class="va">metaStore</span>.<span class="at">carData</span>) <span class="op">{</span>
         <span class="cf">return</span> <span class="at">dispatch</span>(<span class="st">&#39;CAR-DATA-CHANGE&#39;</span><span class="op">,</span> <span class="va">metaStore</span>.<span class="at">carData</span>)   
      <span class="op">}</span>       
      <span class="at">dispatch</span>(<span class="st">&#39;LOAD-CAR-DATA&#39;</span>)<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span></code></pre></div>
<p>The example shown above works as a sort of a cache as well. When the car data was already available it won't be loaded from theserver. Rather the handler will dispatch the existing car data into the app-wide bit space. Of course it's a good question whether caching data in the browser is desirable at all in the first place. Some even say that web sockets are a better way for data communication between a browser based app and the server - and they might be even right! But let's address this question later on.</p>
<p>Now we need, of course, someone to listen for 'LOAD-CAR-DATA' event. That listener will need to load the actual data when the event was received. We can implement this event handler wherever we like but It's conventient to do it inside the MetaStore now that it's not all too big at this point. When the file size grows too big, I think, ethen it's the right time to split handlers into separate files. Let's add the car data loading request handler inside initMetaStore function:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">export</span> <span class="kw">const</span> initMetaStore <span class="op">=</span> () <span class="op">=&gt;</span> <span class="op">{</span>
   
   ...
   
   <span class="at">handle</span>(<span class="st">&#39;LOAD-CAR-DATA&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="va">axios</span>.<span class="at">get</span>(<span class="vs">`</span><span class="sc">${</span>YOUR_CAR_DATA_URL_HERE<span class="sc">}</span><span class="vs">`</span>)
         .<span class="at">then</span>(response <span class="op">=&gt;</span> <span class="op">{</span>
             <span class="at">dispatch</span>(<span class="st">&#39;LOAD-CAR-DATA-SUCCESS&#39;</span><span class="op">,</span> <span class="va">response</span>.<span class="at">data</span>)
         <span class="op">}</span>)
        .<span class="at">catch</span>(error <span class="op">=&gt;</span> <span class="at">dispatch</span>(<span class="st">&quot;LOAD-CAR-DATA-ERROR&quot;</span><span class="op">,</span> error))<span class="op">;</span>
      <span class="op">}</span>)
   <span class="op">}</span>)<span class="op">;</span>
}<span class="op">;</span></code></pre></div>
<p>Now let's decide what to do when the requested data was loaded from the server. We just get the response data from the server and place it into the central MetaStore. And most kindly, we also nothtify about car data change so all related components can update themselves with the new fresh data. Note that I am cloning the data with spread operator {...data} to prevent the central data being changed by a hideous direct manipulation somewhere else int the app!</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">handle</span>(<span class="st">&#39;LOAD-CAR-DATA-SUCCESS&#39;</span><span class="op">,</span> (data) <span class="op">=&gt;</span> <span class="op">{</span>
   <span class="va">metaStore</span>.<span class="at">carData</span> <span class="op">=</span> data<span class="op">;</span>
   <span class="at">dispatch</span>(<span class="st">&#39;CAR-DATA-CHANGE&#39;</span><span class="op">,</span> <span class="op">{</span>...<span class="va">metaStore</span>.<span class="at">carData</span><span class="op">}</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>After defining these handlers, the MetaStore.js file should appear as follows:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span>dispatch<span class="op">,</span> handle<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;synchronous-dispatcher&#39;</span>
<span class="im">import</span> axios <span class="im">from</span> <span class="st">&#39;axios&#39;</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span>CAR_DATA_URL<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;../constants&#39;</span><span class="op">;</span>

<span class="kw">const</span> metaStore <span class="op">=</span> <span class="op">{</span>
  <span class="dt">carDetails</span><span class="op">:</span> <span class="kw">null</span>
<span class="op">};</span>

<span class="im">export</span> <span class="kw">const</span> initMetaStore <span class="op">=</span> () <span class="op">=&gt;</span> <span class="op">{</span>

  <span class="at">handle</span>(<span class="st">&#39;REQUEST-CAR-DATA&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="cf">if</span> (<span class="va">metaStore</span>.<span class="at">carData</span>) <span class="op">{</span>
      <span class="cf">return</span> <span class="at">dispatch</span>(<span class="st">&#39;CAR-DATA-CHANGE&#39;</span><span class="op">,</span> <span class="va">metaStore</span>.<span class="at">carData</span>)
    <span class="op">}</span>
    <span class="at">dispatch</span>(<span class="st">&#39;LOAD-CAR-DATA&#39;</span>)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>

  <span class="at">handle</span>(<span class="st">&#39;LOAD-CAR-DATA&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="va">axios</span>.<span class="at">get</span>(<span class="vs">`</span><span class="sc">${</span>CAR_DATA_URL<span class="sc">}</span><span class="vs">`</span>)
    .<span class="at">then</span>(response <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="at">dispatch</span>(<span class="st">&#39;LOAD-CAR-DATA-SUCCESS&#39;</span><span class="op">,</span> <span class="va">response</span>.<span class="at">data</span>)
    <span class="op">}</span>).<span class="at">catch</span>(error <span class="op">=&gt;</span> <span class="at">dispatch</span>(<span class="st">&quot;LOAD-CAR-DATA-ERROR&quot;</span><span class="op">,</span> error))<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>

  <span class="at">handle</span>(<span class="st">&#39;LOAD-CAR-DATA-SUCCESS&#39;</span><span class="op">,</span> (data) <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="va">metaStore</span>.<span class="at">carDetails</span> <span class="op">=</span> data<span class="op">;</span>
    <span class="at">dispatch</span>(<span class="st">&#39;CAR-DATA-CHANGE&#39;</span><span class="op">,</span> <span class="op">{</span>...<span class="va">metaStore</span>.<span class="at">carDetails</span><span class="op">}</span>)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span></code></pre></div>
<h2 id="turning-your-events-into-constants">Turning Your Events Into Constants</h2>
<p>When dispatching and handling events, you can always use plain strings, as in the previous examples. But this practice will become hazardous over time. If you make a typing mistake when firing events, you may end up puzzled when you are trying to figure out why your handler doesn't appear to react to the event. It may be worth of a debatte to ask whether constants should be defined in a dedicated file or should you rather introduce them as a part of an existing file. My opinion is that the ideal place the event constants is right in the file where the MetaStore resides. When MetaStore grows bigger, it might be worth of considering to separate the constants in a separate file. Until then, the constantized MetaStore file will appear as follows:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span>dispatch<span class="op">,</span> handle<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;synchronous-dispatcher&#39;</span>
<span class="im">import</span> axios <span class="im">from</span> <span class="st">&#39;axios&#39;</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span>CAR_DATA_URL<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;../constants&#39;</span><span class="op">;</span>

<span class="im">export</span> <span class="kw">const</span> REQUEST_CAR_DATA <span class="op">=</span> <span class="st">&#39;REQUEST_CAR_DATA&#39;</span><span class="op">;</span>
<span class="im">export</span> <span class="kw">const</span> CAR_DATA_CHANGE <span class="op">=</span> <span class="st">&#39;CAR_DATA_CHANGE&#39;</span><span class="op">;</span>
<span class="im">export</span> <span class="kw">const</span> LOAD_CAR_DATA <span class="op">=</span> <span class="st">&#39;CAR_DATA_CHANGE&#39;</span><span class="op">;</span>
<span class="im">export</span> <span class="kw">const</span> LOAD_CAR_DATA_SUCCESS <span class="op">=</span> <span class="st">&#39;LOAD_CAR_DATA_SUCCESS&#39;</span><span class="op">;</span>
<span class="im">export</span> <span class="kw">const</span> LOAD_CAR_DATA_ERROR <span class="op">=</span> <span class="st">&#39;LOAD_CAR_DATA_ERROR&#39;</span><span class="op">;</span>

<span class="kw">const</span> metaStore <span class="op">=</span> <span class="op">{</span>
  <span class="dt">carDetails</span><span class="op">:</span> <span class="kw">null</span>
<span class="op">};</span>

<span class="im">export</span> <span class="kw">const</span> initMetaStore <span class="op">=</span> () <span class="op">=&gt;</span> <span class="op">{</span>

  <span class="at">handle</span>(REQUEST_CAR_DATA<span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="cf">if</span> (<span class="va">metaStore</span>.<span class="at">carData</span>) <span class="op">{</span>
      <span class="cf">return</span> <span class="at">dispatch</span>(CAR_DATA_CHANGE<span class="op">,</span> <span class="va">metaStore</span>.<span class="at">carData</span>)
    <span class="op">}</span>
    <span class="at">dispatch</span>(LOAD_CAR_DATA)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>

  <span class="at">handle</span>(LOAD_CAR_DATA<span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="va">axios</span>.<span class="at">get</span>(<span class="vs">`</span><span class="sc">${</span>CAR_DATA_URL<span class="sc">}</span><span class="vs">`</span>)
    .<span class="at">then</span>(response <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="at">dispatch</span>(LOAD_CAR_DATA_SUCCESS<span class="op">,</span> <span class="va">response</span>.<span class="at">data</span>)
    <span class="op">}</span>).<span class="at">catch</span>(error <span class="op">=&gt;</span> <span class="at">dispatch</span>(LOAD_CAR_DATA_ERROR<span class="op">,</span> error))<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>

  <span class="at">handle</span>(<span class="st">&#39;LOAD-CAR-DATA-SUCCESS&#39;</span><span class="op">,</span> (data) <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="va">metaStore</span>.<span class="at">carDetails</span> <span class="op">=</span> data<span class="op">;</span>
    <span class="at">dispatch</span>(CAR_DATA_CHANGE<span class="op">,</span> <span class="op">{</span>...<span class="va">metaStore</span>.<span class="at">carDetails</span><span class="op">}</span>)<span class="op">;</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span></code></pre></div>
<p>Please check GitHub for changes made to turn MetaStore events into constants <a href="https://github.com/develprr/metamatic-car-app/commit/3b45f8a444e604db7e5474d6f3d5c962335b00e9">here</a>. To check the complete source file of this MetaStore implementation please check <a href="https://github.com/develprr/metamatic-car-app/blob/master/src/store/MetaStore.js" title="MetaStore.js">here</a>.</p>
<h2 id="initializing-the-metastore">Initializing the MetaStore</h2>
<p>When you have implemented MetaStore, make sure to actually initialize it by calling initMetaStore function. A good play to do this is at the earliest point of the Application wakeup, for instance in the constructor of App's main component, for example App.js, as many React apps tend to have as their main object:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">class</span> App <span class="kw">extends</span> <span class="va">React</span>.<span class="at">Component</span> <span class="op">{</span>

  <span class="at">constructor</span>(props) <span class="op">{</span>
    <span class="kw">super</span>(props)<span class="op">;</span>
    <span class="at">initMetaStore</span>()<span class="op">;</span>
    ...
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h2 id="create-the-mock-server">Create the Mock Server</h2>
<p>When you start creating any serious frontend app, be sure to implement a mock server for serving fake data for your frontend app as soon as possible. There may be some people saying that you shouldn't use mock data at all but rather rely on real data. That may be true at some point of the application development cycle. But that point comes into question rather later on when the design meets the very minimal definition of maturity and there is already some insight into the needed database structure.</p>
<p>But when you are implementing a new solution from scratch, I highly recommend to implement a mock server in the very beginning of the project, until the business department has come up with a clearer vision about how the software should actually function. If you wait for the &quot;final data&quot; before starting to implement the frontend, you will have a grave chicken-and-egg problem. The business won't ever be able to envision what they really want if they don't have the inital app - even with mock data - that they can play with to decide how the app should work. Therefore you must create a mock data server so you can speed up quickly to implement a frontend based on the early wireframes. When the business department can test out how the demo works then the ideas will be pouring out of these experiences like a fountain of wisdom - helping define the required database structure. If you start creating the software upside down, starting from database and server-side implementation, it will surely slow down all development to<br />
snail speed because you don't even know in the first place how the data should be structured to make the optimal app possible. All changes to the frontend will be extremely slow and expensive - of course depending a bit on how heavy the server side design is.</p>
<p>Frontend is the starting point for new innovative software solutions, not the backend. Therefore the backend must be as light as possible in the very formative phase of the new software, so it can adapt fast to even radical UI design changes that will be coming in first with a rapid cycle, then somewhat slower and more moderate when insight and consensus start to form up.</p>
<p>Creating the initial mock server for the evolving app is actually ridiculously easy:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> bodyParser <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;body-parser&#39;</span>)<span class="op">;</span>
<span class="kw">var</span> cors <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;cors&#39;</span>)<span class="op">;</span>
<span class="kw">var</span> express <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;express&#39;</span>)<span class="op">;</span>
<span class="kw">var</span> path <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;path&#39;</span>)<span class="op">;</span>
<span class="kw">var</span> app <span class="op">=</span> <span class="at">express</span>()<span class="op">;</span>

<span class="va">app</span>.<span class="at">use</span>(<span class="va">bodyParser</span>.<span class="at">urlencoded</span>(<span class="op">{</span>
  <span class="dt">extended</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span>))<span class="op">;</span>

<span class="va">app</span>.<span class="at">use</span>(<span class="va">bodyParser</span>.<span class="at">json</span>())<span class="op">;</span>
<span class="va">app</span>.<span class="at">use</span>(<span class="at">cors</span>())<span class="op">;</span>
<span class="va">app</span>.<span class="at">use</span>(<span class="va">express</span>.<span class="at">static</span>(<span class="st">&#39;public&#39;</span>))<span class="op">;</span>


<span class="va">app</span>.<span class="at">use</span>(<span class="st">&#39;/app&#39;</span><span class="op">,</span> <span class="va">express</span>.<span class="at">static</span>(<span class="st">&#39;public&#39;</span>))
<span class="va">app</span>.<span class="at">use</span>(<span class="st">&#39;/app&#39;</span><span class="op">,</span> <span class="va">express</span>.<span class="at">static</span>(<span class="va">path</span>.<span class="at">join</span>(__dirname<span class="op">,</span> <span class="st">&#39;public&#39;</span>)))

<span class="va">app</span>.<span class="at">get</span>(<span class="st">&#39;/api/car-details&#39;</span><span class="op">,</span> <span class="kw">function</span>(req<span class="op">,</span> res) <span class="op">{</span>
  <span class="va">res</span>.<span class="at">json</span>(<span class="op">{</span>
    <span class="dt">speed</span><span class="op">:</span> <span class="fl">211.0</span><span class="op">,</span>
    <span class="dt">color</span><span class="op">:</span> <span class="st">&#39;blue&#39;</span><span class="op">,</span>
    <span class="dt">model</span><span class="op">:</span> <span class="st">&#39;Alpha Julia&#39;</span><span class="op">,</span>
    <span class="dt">price</span><span class="op">:</span> <span class="fl">28000.0</span>
  <span class="op">}</span>)
<span class="op">}</span>)<span class="op">;</span>

<span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> app<span class="op">;</span>
<span class="va">app</span>.<span class="at">listen</span>(<span class="dv">3001</span>)<span class="op">;</span></code></pre></div>
<p>It's just <a href="https://github.com/develprr/metamatic-car-app/commit/f0e26ed24f8e50eb86d17e6c26924c2774fac2bb">one silly commit</a> alltogether!a</p>
<h2 id="strip-off-complexity-with-central-event-handling">Strip Off Complexity With Central Event Handling</h2>
<p>When you start creating frontend software with ReactJS and implement new components, you will notice over time how your component hierarchy grows into a tree-like structure. It will become challenging to pass events events from leaf components downward toward the root component. For instance, when user clicks LoginButton component on LoginForm component, you must fire a click event inside LoginButton that is then handled by parent LoginForm component. LoginForm component then forwards event further to its parent and so on, until the event reaches the component that can do the actually login validation. This kind of event &quot;bubbling&quot; through hierarchy creates incredibly much unnecessary complexity in your App because you must remember to implement an ever growing chain on event dispatchers and handlers all the way through the hierarchy starting from the leaf until the root component. This kind of event bubbling degrades the application over time extremely unmaintainable and difficult to follow. All changes in the logic will be slow and error prone to implement because of the chain reaction of changes that always follows even on the slightest change in the application logic. But you can avoid this kind of bubbling complexity completely if you implement a central location for handling events, the MetaStore!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Note that I am here splitting the logic into many sections that are quite loosely coupled to each other. Different parts of the logic live their independent life, being loosely connected only through events. There are many advocates of this kind of event-driven approach. However, I would warn against going too event-driven in the first place. The idea of events is to disconnect parts of the application from each other in the name of modularity. But disconnectedness may actually be a very bad thing. It's easy for a developer to follow the logic by clicking on a method call when using a proper editor.</p>
<p>But when you have broken the direct connection between two different methods by joining them together not through direct method invocation but rather via events - with one function firing an event and another listening for it - you have just created an extra layer of complexity. From then on you will always need a bit more detective work to follow the application logic. You must search where the event was defined and where it's being expected. It makes the code more difficult to read. And the software code is always written as much for humans as for the machine. This concern is a major justification for writing very standard code always when possible - avoiding too much innovation - even if it results in somewhat lower results/time spent ratio. But there will always be unique problems that can only be addressed with unique code.</p>
<p>Either way, I hope these examples hightlight the idea of a very easy, very straightforward, over-engineering-free approach to implement robust central data storage without too complex frameworks.</p>
<h2 id="coming-soon...">Coming Soon...</h2>
<p>I can barely wait to continue highlighting The Metamatic Approach: An event-driven, minimalistic, simple way to manage data in your app. I'll be back to you soon with more examples about the topic!</p>

                </div>
            </div>
        </div>
    </article>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul style="display:none" class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
		    <p class="copyright text-muted">View this article on <a href="https://github.com/develprr/oppikone-blog/commits/master/introducing-metamate-framework.html">GitHub!</a></p>
                    <p class="copyright text-muted">Copyright &copy; Oppikone 2018</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>

</body>

</html>